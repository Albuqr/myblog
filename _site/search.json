[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "Welcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nNov 19, 2025\n\n\nTristan O’Malley\n\n\n\n\n\n\n\n\n\n\n\n\nCotação do Dólar por Período\n\n\nConsulta à API PTAX do Banco Central e geração de gráfico interativo\n\n\n\n\n\nFeb 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nRegressao Linear com Plotnine\n\n\ncarrega dados de x e y, calcula regressao linear e gera grafico com plotnine\n\n\n\n\n\nFeb 1, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Cotação do Dólar por Período",
    "section": "",
    "text": "import os import calendar from datetime import datetime\nimport requests import pandas as pd import plotly.express as px from dotenv import load_dotenv\nload_dotenv()\nBCB_API = os.getenv( “BCB_API”, “https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata” )\nBCB_DOLAR_ENDPOINT = os.getenv( “BCB_DOLAR_ENDPOINT”, “CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)” )\nMES_ANO = os.getenv(“DOLAS_MES_ANO”, “082021”)\ndef datas_mes(mmyyyy: str): primeiro = datetime.strptime(mmyyyy, “%m%Y”) ultimodia = calendar.monthrange(primeiro.year, primeiro.month)[1] ultimo = primeiro.replace(day=ultimodia) return primeiro, ultimo\ndef dolardados(mmyyyy: str): inicio, fim = datas_mes(mmyyyy)\nurl = (\n    f\"{BCB_API}/\"\n    f\"{BCB_DOLAR_ENDPOINT}?\"\n    f\"@dataInicial='{inicio.strftime('%m-%d-%Y')}'&\"\n    f\"@dataFinalCotacao='{fim.strftime('%m-%d-%Y')}'&\"\n    \"$top=10000&$format=json\"\n)\n\nresposta = requests.get(url)\nresposta.raise_for_status()\nreturn resposta.json()[\"value\"]\ndef organizardados(dados, mmyyyy: str): df = pd.DataFrame(dados) df[“data”] = pd.to_datetime(df[“dataHoraCotacao”]).dt.date df = df[[“data”, “cotacaoVenda”]].sort_values(“data”)\ninicio, fim = datas_mes(mmyyyy)\ncalendario = pd.date_range(start=inicio, end=fim).date\ndf_full = pd.DataFrame({\"data\": calendario})\n\ndf_full = df_full.merge(df, on=\"data\", how=\"left\")\ndf_full[\"cotacaoVenda\"] = df_full[\"cotacaoVenda\"].ffill()\n\nreturn df_full\ndef plot(df: pd.DataFrame, mmyyyy: str): titulo = f”Cotação do Dólar – {mmyyyy[:2]}/{mmyyyy[2:]}” fig = px.line(df, x=“data”, y=“cotacaoVenda”, title=titulo) fig.update_layout( xaxis_title=“Data”, yaxis_title=“Cotação de venda (R$)” ) return fig\ndef f(mmyyyy: str | None = None): if mmyyyy is None: mmyyyy = MES_ANO\ndados = dolardados(mmyyyy)\ndf_tratado = organizardados(dados, mmyyyy)\nfig = plot(df_tratado, mmyyyy)\n\n# IMPORTANTE: nada de fig.show()\n# A ÚLTIMA LINHA da função deve retornar o fig para o Quarto renderizar.\nreturn df_tratado, fig\n\nExecuta e deixa o gráfico como última expressão → Quarto renderiza\ndf_final, fig = f() fig"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/onibus.html",
    "href": "posts/post-with-code/onibus.html",
    "title": "teste",
    "section": "",
    "text": "import os import requests from dotenv import load_dotenv, find_dotenv # ⬅️ acrescenta find_dotenv import folium import webbrowser\n\nEm vez de load_dotenv(“.env”):\nload_dotenv(find_dotenv()) TOKEN = os.getenv(“SPTRANS_TOKEN”) API = “http://api.olhovivo.sptrans.com.br/v2.1”\n\n\nusa a linha definida no .env\nlinha_usuario = os.getenv(“LINHA_TERMO_BUSCA”)\ns = requests.Session() res = s.post(f”{API}/Login/Autenticar?token={TOKEN}“) print(”Autenticação:“, res.text)\ndef buscar_codigos(entrada): termo = entrada.split(“-”)[0] r = s.get(f”{API}/Linha/Buscar?termosBusca={termo}“) dados = r.json() print(”encontradas:“) for d in dados: print(d) return [d[“cl”] for d in dados]\ndef buscar_itinerario(cod): r = s.get(f”{API}/Itinerario?codigoLinha={cod}“) data = r.json() traj = [[v[“py”], v[“px”]] for k, v in data.items() if k.isdigit()] par = [{“nome”: v[“np”], “lat”: v[“py”], “lng”: v[“px”]} for k, v in data.items() if k.startswith(“p”)] return traj, par\ndef buscar_posicao(cod): r = s.get(f”{API}/Posicao/Linha?codigoLinha={cod}“) return r.json().get(”vs”, [])\ntodos_codigos = buscar_codigos(linha_usuario)\nmelhor_trajeto = None melhor_paradas = None codigo_escolhido = None\nprint(“códigos…”)\nfor cod in todos_codigos: traj, par = buscar_itinerario(cod) print(f”Código {cod} → Pontos: {len(traj)} / Paradas: {len(par)}“) if len(traj) &gt; 0: melhor_trajeto = traj melhor_paradas = par codigo_escolhido = cod break\nif melhor_trajeto is None: print(“itinerário com trajeto. Testando paradas.”) for cod in todos_codigos: r = s.get(f”{API}/Parada/BuscarParadasPorLinha?codigoLinha={cod}“) par = r.json() if len(par) &gt; 0: melhor_paradas = [{”nome”: p[”np”], ”lat”: p[”py”], ”lng”: p[”px”]} for p in par] melhor_trajeto = [] codigo_escolhido = cod print(f”Usando paradas do código {cod}“) break\nif melhor_paradas is None and melhor_trajeto is None: raise Exception(“API sem dados para essa linha.”)\nveiculos = buscar_posicao(codigo_escolhido) print(f”encontrados: {len(veiculos)}“)\nif melhor_trajeto: lat0, lng0 = melhor_trajeto[0] else: lat0, lng0 = melhor_paradas[0][“lat”], melhor_paradas[0][“lng”]\nm = folium.Map(location=[lat0, lng0], zoom_start=13)\nif melhor_trajeto: folium.PolyLine(melhor_trajeto, weight=4, color=“blue”).add_to(m)\nfor p in melhor_paradas: folium.Marker( [p[“lat”], p[“lng”]], popup=p[“nome”], icon=folium.Icon(color=“green”) ).add_to(m)\nfor v in veiculos: folium.Marker( [v[“py”], v[“px”]], popup=f”Prefixo: {v[‘p’]}“, icon=folium.Icon(color=”red”) ).add_to(m)\nm.save(“onibus_mapa.html”) webbrowser.open(“onibus_mapa.html”)\nprint(“gerado: onibus_mapa.html”)"
  },
  {
    "objectID": "posts/post-with-code/onibus.html#monitoramento-da-linha-de-ônibus",
    "href": "posts/post-with-code/onibus.html#monitoramento-da-linha-de-ônibus",
    "title": "Mapa em tempo real da linha de ônibus",
    "section": "",
    "text": "Este post consulta a API Olho Vivo da SPTrans usando o token configurado no arquivo .env e monta um mapa com:\n\nParadas da linha (marcadores azuis)\n\nÔnibus em tempo real (marcadores vermelhos)\n\nA linha utilizada é lida da variável CODIGO_LINHA no .env.\nimport os from IPython.display import HTML\nfrom onibus import ( autsessao, buscaparadas, bucarposicoes, fazermapa, CODIGO_LINHA, TERMO_BUSCA_LINHA, )"
  },
  {
    "objectID": "posts/post-with-code/dolar.html",
    "href": "posts/post-with-code/dolar.html",
    "title": "Cotação do Dólar por Período",
    "section": "",
    "text": "import os\nimport calendar\nfrom datetime import datetime\n\nimport requests\nimport pandas as pd\nimport plotly.express as px\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nBCB_API = os.getenv(\n    \"BCB_API\",\n    \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata\"\n)\n\nBCB_DOLAR_ENDPOINT = os.getenv(\n    \"BCB_DOLAR_ENDPOINT\",\n    \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n)\n\nMES_ANO = os.getenv(\"DOLAR_MES_ANO\")\n\n\ndef datas_mes(mmyyyy: str):\n    # recebe uma string como mes/ano e devolve o primeiro e ultimo dia como datetime\n\n    primeiro = datetime.strptime(mmyyyy, \"%m%Y\")\n    ultimodia = calendar.monthrange(primeiro.year, primeiro.month)[1]\n    ultimo = primeiro.replace(day=ultimodia)\n    return primeiro, ultimo\n\n\ndef dolardados(mmyyyy: str):\n    # pega os dados da cotação no periodo escolhido, mes/ano\n\n    inicio, fim = datas_mes(mmyyyy)\n\n    # url base pra pegar os dados em json\n    url = (\n        f\"{BCB_API}/\"\n        f\"{BCB_DOLAR_ENDPOINT}?\"\n        f\"@dataInicial='{inicio.strftime('%m-%d-%Y')}'&\"\n        f\"@dataFinalCotacao='{fim.strftime('%m-%d-%Y')}'&\"\n        \"$top=10000&$format=json\"\n    )\n\n    resposta = requests.get(url)\n    resposta.raise_for_status()\n    dados = resposta.json()[\"value\"]\n    return dados\n\n\ndef organizardados(dados, mmyyyy: str):\n    # organiza os dados do json em dataframe, basicamente faz um calendario,\n    # dia que nao tiver cotação fica com a mesma do dia anterior\n\n    df = pd.DataFrame(dados)\n    df[\"data\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df[[\"data\", \"cotacaoVenda\"]].sort_values(\"data\")\n\n    inicio, fim = datas_mes(mmyyyy)\n    calendario = pd.date_range(start=inicio, end=fim).date\n    df_full = pd.DataFrame({\"data\": calendario})\n\n    df_full = df_full.merge(df, on=\"data\", how=\"left\")\n\n    df_full[\"cotacaoVenda\"] = df_full[\"cotacaoVenda\"].ffill()\n\n    return df_full\n\n\ndef plot(df: pd.DataFrame, mmyyyy: str):\n    # usa o plotly pra fazer o grafico do valor do dolar\n\n    titulo = f\"Cotação do Dólar – {mmyyyy[:2]}/{mmyyyy[2:]}\"\n    fig = px.line(df, x=\"data\", y=\"cotacaoVenda\", title=titulo)\n    fig.update_layout(\n        xaxis_title=\"Data\",\n        yaxis_title=\"Cotação de venda (R$)\"\n    )\n    return fig\n\n\ndef f(mmyyyy: str | None = None):\n    # função principal, pega o mes/ano do .env e organiza os dados das outras funções\n\n    if mmyyyy is None:\n        mmyyyy = MES_ANO\n\n    dados = dolardados(mmyyyy)\n    df_tratado = organizardados(dados, mmyyyy)\n    fig = plot(df_tratado, mmyyyy)\n    fig.show()\n    return df_tratado, fig\n\n\n# chama a função principal e mostra o gráfico (como no teste do Plotly)\ndf_final, fig = f()"
  },
  {
    "objectID": "posts/post-with-code/teste.html",
    "href": "posts/post-with-code/teste.html",
    "title": "teste",
    "section": "",
    "text": "import os import requests from dotenv import load_dotenv import folium import webbrowser\nload_dotenv(“.env”) TOKEN = os.getenv(“ONIBUS_TOKEN”) API = “http://api.olhovivo.sptrans.com.br/v2.1”\nlinha_usuario = “2506”\ns = requests.Session() res = s.post(f”{API}/Login/Autenticar?token={TOKEN}“) print(”Autenticação:“, res.text)\ndef buscar_codigos(entrada): termo = entrada.split(“-”)[0] r = s.get(f”{API}/Linha/Buscar?termosBusca={termo}“) dados = r.json() print(”encontradas:“) for d in dados: print(d) return [d[“cl”] for d in dados]\ndef buscar_itinerario(cod): r = s.get(f”{API}/Itinerario?codigoLinha={cod}“) data = r.json() traj = [[v[“py”], v[“px”]] for k, v in data.items() if k.isdigit()] par = [{“nome”: v[“np”], “lat”: v[“py”], “lng”: v[“px”]} for k, v in data.items() if k.startswith(“p”)] return traj, par\ndef buscar_posicao(cod): r = s.get(f”{API}/Posicao/Linha?codigoLinha={cod}“) return r.json().get(”vs”, [])\ntodos_codigos = buscar_codigos(linha_usuario)\nmelhor_trajeto = None melhor_paradas = None codigo_escolhido = None\nprint(“códigos…”)\nfor cod in todos_codigos: traj, par = buscar_itinerario(cod) print(f”Código {cod} → Pontos: {len(traj)} / Paradas: {len(par)}“) if len(traj) &gt; 0: melhor_trajeto = traj melhor_paradas = par codigo_escolhido = cod break\nif melhor_trajeto is None: print(“itinerário com trajeto. Testando paradas.”) for cod in todos_codigos: r = s.get(f”{API}/Parada/BuscarParadasPorLinha?codigoLinha={cod}“) par = r.json() if len(par) &gt; 0: melhor_paradas = [{”nome”: p[”np”], ”lat”: p[”py”], ”lng”: p[”px”]} for p in par] melhor_trajeto = [] codigo_escolhido = cod print(f”Usando paradas do código {cod}“) break\nif melhor_paradas is None and melhor_trajeto is None: raise Exception(“API sem dados para essa linha.”)\nveiculos = buscar_posicao(codigo_escolhido) print(f”encontrados: {len(veiculos)}“)\nif melhor_trajeto: lat0, lng0 = melhor_trajeto[0] else: lat0, lng0 = melhor_paradas[0][“lat”], melhor_paradas[0][“lng”]\nm = folium.Map(location=[lat0, lng0], zoom_start=13)\nif melhor_trajeto: folium.PolyLine(melhor_trajeto, weight=4, color=“blue”).add_to(m)\nfor p in melhor_paradas: folium.Marker( [p[“lat”], p[“lng”]], popup=p[“nome”], icon=folium.Icon(color=“green”) ).add_to(m)\nfor v in veiculos: folium.Marker( [v[“py”], v[“px”]], popup=f”Prefixo: {v[‘p’]}“, icon=folium.Icon(color=”red”) ).add_to(m)\nm.save(“onibus_mapa.html”) webbrowser.open(“onibus_mapa.html”)\nprint(“gerado: onibus_mapa."
  },
  {
    "objectID": "posts/post-with-code/posts/post-with-code/regressao.html",
    "href": "posts/post-with-code/posts/post-with-code/regressao.html",
    "title": "Regressao Linear com Plotnine",
    "section": "",
    "text": "import os\nimport requests\nfrom io import StringIO\n\nimport numpy as np\nimport pandas as pd\nfrom dotenv import load_dotenv, find_dotenv\nfrom plotnine import ggplot, aes, geom_point, geom_abline, theme, element_text, ggsave\nfrom IPython.display import Image, display  # mostra a imagem no post\n\n# carrega variaveis do arquivo .env\nload_dotenv(find_dotenv())\n\nURLX = os.getenv(\"URL_X\")\nURLY = os.getenv(\"URL_Y\")\n\n\ndef carregardados(urlx: str, urly: str):\n    # carrega vetores x e y dos arquivos\n\n    if not urlx or not urly:\n        raise ValueError(\"urlx ou urly invalido\")\n\n    # limpa espacos e aspas\n    urlx = urlx.strip().strip('\"').strip(\"'\")\n    urly = urly.strip().strip('\"').strip(\"'\")\n\n    # se arquivo local, abre direto\n    if os.path.isfile(urlx):\n        with open(urlx, \"r\", encoding=\"utf-8\") as f:\n            x = np.loadtxt(StringIO(f.read()))\n    else:\n        resp_x = requests.get(urlx)\n        resp_x.raise_for_status()\n        x = np.loadtxt(StringIO(resp_x.text))\n\n    if os.path.isfile(urly):\n        with open(urly, \"r\", encoding=\"utf-8\") as f:\n            y = np.loadtxt(StringIO(f.read()))\n    else:\n        resp_y = requests.get(urly)\n        resp_y.raise_for_status()\n        y = np.loadtxt(StringIO(resp_y.text))\n\n    x = np.asarray(x).ravel()\n    y = np.asarray(y).ravel()\n\n    if x.shape[0] != y.shape[0]:\n        raise ValueError(\"tamanhos diferentes entre x e y\")\n\n    return x, y\n\n\ndef regressaomatriz(x: np.ndarray, y: np.ndarray):\n    # calcula coeficientes da regressao linear\n\n    X = np.column_stack((np.ones_like(x), x))\n\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    Xty = X.T @ y\n    beta = XtX_inv @ Xty\n\n    a = float(beta[0])  # intercepto\n    b = float(beta[1])  # inclinacao\n\n    return a, b\n\n\ndef fazgrafico(\n    x: np.ndarray,\n    y: np.ndarray,\n    a: float,\n    b: float,\n    nome_arquivo: str = \"grafico_regressao.png\",\n):\n    # monta o grafico com pontos e a reta de regressao\n\n    df = pd.DataFrame({\"x\": x, \"y\": y})\n\n    plot = (\n        ggplot(df, aes(\"x\", \"y\"))\n        + geom_point()\n        + geom_abline(intercept=a, slope=b)\n        + theme(\n            axis_title_x=element_text(size=12),\n            axis_title_y=element_text(size=12),\n            figure_size=(6, 4),\n        )\n    )\n\n    # salva imagem\n    ggsave(plot, filename=nome_arquivo, dpi=300)\n\n    return plot\n\n\ndef f(url_x: str | None = None, url_y: str | None = None):\n    # fluxo principal do codigo\n\n    if url_x is None:\n        url_x = URLX\n    if url_y is None:\n        url_y = URLY\n\n    x, y = carregardados(url_x, url_y)\n    a, b = regressaomatriz(x, y)\n\n    print(f\"intercepto (a): {a}\")\n    print(f\"inclinacao (b): {b}\")\n\n    plot = fazgrafico(x, y, a, b)\n    print(\"grafico salvo em grafico_regressao.png\")\n\n    return a, b, plot\n\n\n# executa o fluxo principal\na, b, plot = f()\n\n# exibe a imagem no post\ndisplay(Image(\"grafico_regressao.png\"))\n\nintercepto (a): 373.93446839132355\ninclinacao (b): 991.6278332981952\n\n\n/home/codespace/.python/current/lib/python3.12/site-packages/plotnine/ggplot.py:623: PlotnineWarning: Saving 6 x 4 in image.\n/home/codespace/.python/current/lib/python3.12/site-packages/plotnine/ggplot.py:624: PlotnineWarning: Filename: grafico_regressao.png\n\n\ngrafico salvo em grafico_regressao.png"
  }
]